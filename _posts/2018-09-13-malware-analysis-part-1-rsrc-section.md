---
title: "Malware analysis - Part 1 - .rsrc Section"
date: 2018-09-13 22:00:00
excerpt: ""
---

Starting from this post I would like to share my recent studies into malware analysis.
I am going to begin with basic concepts and proceed to advanced stuff.

Malware analysis has 2 main approaches: <strong>static</strong> and <strong>dynamic</strong>. The former approach statically analyze the malware without execute it, the latter execute the malware and studies it's behavior at runtime.

For the purpose of this post, I will illustrate the static approch only.

## Target

I chose a malware with the characteristics below:
- It must run on Windows
- It must be known already
- It must be simple to analyze => no packers or obfuscation

There are milions of malware with above characteristics, I chose:

| Name           | MD5                               | Download         |
| -------------- | --------------------------------- | ---------------- |
| Downloader-CUZ | 149210e204404d9ac13aee43b9a7e4a7  | (Link)[]         |

This malware does a lot of operations. Here I will analyze only a specific feature of this malware: embedded binary into .rsrc section.

## .rsrc Section

The Portable Executable (PE) specifies the structure of executable (image) files on Microsoft Windows. PE format .....

XXX

For a detailed description see [1].

## Analysis

XXX

## Dump all

XXX

```c
#include <Windows.h>
#include <stdio.h>

static LPCVOID LoadMalwareResource(HINSTANCE hModule, const char* resourceName, const char* resourceType) {

	HRSRC hsrc = FindResourceA(hModule, resourceName, resourceType);

	if (!hsrc) {
		fprintf(stderr, "[E][LoadMalwareResource] FindResourceA(): failed! (%d)\n", GetLastError());
		return NULL;
	}

	HGLOBAL hResource = LoadResource(hModule, hsrc);

	if (!hResource) {
		fprintf(stderr, "[E][LoadMalwareResource] LoadResource(): failed! (%d)\n", GetLastError());
		return NULL;
	}

	LPCVOID resource = LockResource(hResource);

	if (!resource) {
		fprintf(stderr, "[E][LoadMalwareResource] LockResource(): failed! (%d)\n", GetLastError());
	}

	return resource;
}

static HINSTANCE LoadMalware(const char* malwareFilePath, const char* malwareFileName) {

	size_t len = strlen(malwareFilePath) + strlen(malwareFileName) + 2;
	char* filename = malloc(len);

	if (!filename) {
		fprintf(stderr, "[E][LoadMalware] free(): failed! (%d)\n", GetLastError());
		return NULL;
	}

	snprintf(filename, len, "%s\\%s", malwareFilePath, malwareFileName);

	HINSTANCE hFile = LoadLibraryA(filename);
	free(filename);

	if (!hFile) {
		fprintf(stderr, "[E][LoadMalware] LoadLibraryA(): failed! (%d)\n", GetLastError());
		return NULL;
	}

	HINSTANCE hModule = GetModuleHandleA(malwareFileName);

	if (!hModule) {
		fprintf(stderr, "[E][LoadMalware] GetModuleHandle(): failed! (%d)\n", GetLastError());
	}

	return hModule;
}

static int SaveMalwareResource(const char* outputFileName, LPCVOID hrA, LPCVOID hrB) {
	
	HANDLE hFile = CreateFileA(outputFileName,
				   GENERIC_WRITE,
				   FILE_SHARE_WRITE,
				   NULL,
				   CREATE_ALWAYS,
				   FILE_ATTRIBUTE_NORMAL,
				   NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[E][SaveMalwareResource] CreateFileA(): failed! (%d)\n", GetLastError());
		return -1;
	}

	long iBytesWritten;
	WriteFile(hFile, hrA, 0x400, &iBytesWritten, NULL);

	const void* phrB = hrB;

	for (int i = 0; i < 17; ++i) {
		WriteFile(hFile, phrB, 0x400, &iBytesWritten, NULL);
		phrB = (char *)phrB + 1024;
	}

	WriteFile(hFile, (char *)hrB + 17408, 0x621, &iBytesWritten, NULL);

	CloseHandle(hFile);

	return 0;
}

int main(int argc, char** argv) {

	if (argc != 4) {
		return -1;
	}

	const char* malwareFilePath = argv[1];
	const char* malwareFileName = argv[2];
	const char* outputFileName = argv[3];

	HINSTANCE hMalware = LoadMalware(malwareFilePath, malwareFileName);

	if (!hMalware) {
		return -1;
	}

	const char* resourceType = "RT_RCDATA";
	LPCVOID hrA = LoadMalwareResource(hMalware, (const char*) 0x6a, resourceType);
	LPCVOID hrB = LoadMalwareResource(hMalware, (const char*) 0x69, resourceType);

	SaveMalwareResource(outputFileName, hrA, hrB);

	return 0;
}

```

## References
- [PE Format - The .rsrc Section](https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#the-rsrc-section)
